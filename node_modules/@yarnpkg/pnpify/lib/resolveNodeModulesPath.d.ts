import { PortablePath, Filename } from '@yarnpkg/fslib';
import { NodeModulesTree } from './buildNodeModulesTree';
/**
 * Resolved `/node_modules` path inside PnP project info.
 *
 * Dirs ending with '/node_modules/foo/node_modules' or '.../node_modules/foo/node_modules/@scope'
 * do not physically exist, but we must pretend they do exist if package `foo` has dependencies
 * and there is some package `@scope/bar` inside these dependencies. We need two things to emulate
 * these dirs existence:
 *
 * 1. List of entries in these dirs. We retrieve them by calling PnP API and getting dependencies
 *    for the issuer `.../foo/` and store into `dirList` field
 * 2. And we need either fake stats or we can forward underlying fs to stat the issuer dir.
 *    The issuer dir exists on fs. We store issuer dir into `statPath` field
 */
export interface ResolvedPath {
    /**
     * Fully resolved path `/node_modules/...` path within PnP project
     */
    resolvedPath: PortablePath;
    /**
     * This field is returned for pathes ending with `/node_modules[/@scope]`.
     *
     * These pathes are special in the sense they do not exists as physical dirs in PnP projects.
     *
     * We emulate these pathes by forwarding to real physical path on underlying fs.
     */
    forwardedDirPath?: PortablePath;
    /**
     * Directory entries list, returned for pathes ending with `/node_modules[/@scope]`
     */
    dirList?: Set<Filename>;
    /**
     * If true, the entry is meant to be a symbolic link to the location pointed by resolvedPath.
     */
    isSymlink?: boolean;
}
/**
 * Resolves paths containing `/node_modules` inside PnP projects. If path is outside PnP
 * project it is not changed.
 *
 * @param inputPath full path containing `node_modules`
 *
 * @returns resolved path
 */
export declare const resolveNodeModulesPath: (inputPath: PortablePath, nodeModulesTree: NodeModulesTree) => ResolvedPath;
