"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSdk = exports.Wrapper = exports.IntegrationsFile = exports.validateIntegrations = exports.getDisplayName = exports.SUPPORTED_INTEGRATIONS = exports.INTEGRATIONS_FILE = exports.SDK_FOLDER = exports.OLD_SDK_FOLDER = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const parsers_1 = require("@yarnpkg/parsers");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const capitalize_1 = tslib_1.__importDefault(require("lodash/capitalize"));
const startCase_1 = tslib_1.__importDefault(require("lodash/startCase"));
const dynamicRequire_1 = require("./dynamicRequire");
const base_1 = require("./sdks/base");
const cocvim_1 = require("./sdks/cocvim");
const vscode_1 = require("./sdks/vscode");
exports.OLD_SDK_FOLDER = `.vscode/pnpify`;
exports.SDK_FOLDER = `.yarn/sdks`;
exports.INTEGRATIONS_FILE = `integrations.yml`;
exports.SUPPORTED_INTEGRATIONS = new Map([
    [`vim`, cocvim_1.COC_VIM_SDKS],
    [`vscode`, vscode_1.VSCODE_SDKS],
]);
const getDisplayName = (name) => startCase_1.default(name).split(` `).map(word => capitalize_1.default(word)).join(` `);
exports.getDisplayName = getDisplayName;
const validateIntegrations = (integrations) => {
    const unsupportedIntegrations = [];
    for (const integration of integrations) {
        if (!exports.SUPPORTED_INTEGRATIONS.has(integration)) {
            unsupportedIntegrations.push(integration);
        }
    }
    if (unsupportedIntegrations.length > 0) {
        throw new clipanion_1.UsageError(`No supported integrations with the following names could be found: ${unsupportedIntegrations.join(`, `)}. Run \`yarn pnpify --sdk -h\` to see the list of supported integrations.`);
    }
};
exports.validateIntegrations = validateIntegrations;
class IntegrationsFile {
    constructor() {
        this.integrations = new Set();
        this.raw = {};
    }
    static async find(projectRoot) {
        const targetFolder = fslib_1.ppath.join(projectRoot, exports.SDK_FOLDER);
        const integrationPath = fslib_1.ppath.join(targetFolder, exports.INTEGRATIONS_FILE);
        if (!fslib_1.xfs.existsSync(integrationPath))
            return null;
        const integrationsFile = new IntegrationsFile();
        await integrationsFile.loadFile(integrationPath);
        return integrationsFile;
    }
    async loadFile(path) {
        const content = await fslib_1.xfs.readFilePromise(path, `utf8`);
        let data;
        try {
            data = parsers_1.parseSyml(content || `{}`);
        }
        catch (error) {
            error.message += ` (when parsing ${path})`;
            throw error;
        }
        this.load(data);
    }
    load(data) {
        if (typeof data !== `object` || data === null)
            throw new Error(`Utterly invalid integrations file data (${data})`);
        this.raw = data;
        if (Array.isArray(data.integrations)) {
            this.integrations = new Set(data.integrations);
            exports.validateIntegrations(this.integrations);
        }
    }
    exportTo(data) {
        if (this.integrations.size > 0)
            data.integrations = [...this.integrations];
        return data;
    }
    async persist(dir) {
        const data = {};
        this.exportTo(data);
        const path = fslib_1.ppath.join(dir, exports.INTEGRATIONS_FILE);
        let content = `# This file is automatically generated by PnPify.\n# Manual changes will be lost!\n\n`;
        content += parsers_1.stringifySyml(data);
        await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(path), { recursive: true });
        await fslib_1.xfs.changeFilePromise(path, content, {
            automaticNewlines: true,
        });
    }
}
exports.IntegrationsFile = IntegrationsFile;
const TEMPLATE = (relPnpApiPath, module, { setupEnv = false, usePnpify = false, wrapModule }) => [
    `#!/usr/bin/env node\n`,
    `\n`,
    `const {existsSync} = require(\`fs\`);\n`,
    `const {createRequire, createRequireFromPath} = require(\`module\`);\n`,
    ...(usePnpify ? [
        `const {resolve, dirname} = require(\`path\`);\n`,
    ] : [
        `const {resolve} = require(\`path\`);\n`,
    ]),
    `\n`,
    `const relPnpApiPath = ${JSON.stringify(fslib_1.npath.fromPortablePath(relPnpApiPath))};\n`,
    `\n`,
    `const absPnpApiPath = resolve(__dirname, relPnpApiPath);\n`,
    `const absRequire = (createRequire || createRequireFromPath)(absPnpApiPath);\n`,
    `\n`,
    ...(wrapModule ? [
        `const moduleWrapper = ${wrapModule.trim().replace(/^ {4}/gm, ``)}\n`,
        `\n`,
    ] : []),
    `if (existsSync(absPnpApiPath)) {\n`,
    `  if (!process.versions.pnp) {\n`,
    `    // Setup the environment to be able to require ${module}\n`,
    `    require(absPnpApiPath).setup();\n`,
    `  }\n`,
    ...(setupEnv ? [
        `\n`,
        `  if (typeof global[\`__yarnpkg_sdk_has_setup_env__\`] === \`undefined\`) {\n`,
        `    Object.defineProperty(global, \`__yarnpkg_sdk_has_setup_env__\`, {configurable: true, value: true});\n`,
        `\n`,
        `    process.env.NODE_OPTIONS = process.env.NODE_OPTIONS || \`\`;\n`,
        `    process.env.NODE_OPTIONS += \` -r \${absPnpApiPath}\`;\n`,
        `  }\n`,
    ] : []),
    ...(usePnpify ? [
        `\n`,
        `  const pnpifyResolution = require.resolve(\`@yarnpkg/pnpify\`, {paths: [dirname(absPnpApiPath)]});\n`,
        `  if (typeof global[\`__yarnpkg_sdk_is_using_pnpify__\`] === \`undefined\`) {\n`,
        `    Object.defineProperty(global, \`__yarnpkg_sdk_is_using_pnpify__\`, {configurable: true, value: true});\n`,
        `\n`,
        `    process.env.NODE_OPTIONS += \` -r \${pnpifyResolution}\`;\n`,
        `\n`,
        `    // Apply PnPify to the current process\n`,
        `    absRequire(pnpifyResolution).patchFs();\n`,
        `  }\n`,
    ] : []),
    `}\n`,
    `\n`,
    `// Defer to the real ${module} your application uses\n`,
    wrapModule ? `module.exports = moduleWrapper(absRequire(\`${module}\`));\n` : `module.exports = absRequire(\`${module}\`);\n`,
].join(``);
class Wrapper {
    constructor(name, { pnpApi, target }) {
        this.paths = new Map();
        this.name = name;
        this.pnpApi = pnpApi;
        this.target = target;
    }
    async writeManifest() {
        const absWrapperPath = fslib_1.ppath.join(this.target, this.name, `package.json`);
        const topLevelInformation = this.pnpApi.getPackageInformation(this.pnpApi.topLevel);
        const dependencyReference = topLevelInformation.packageDependencies.get(this.name);
        const pkgInformation = this.pnpApi.getPackageInformation(this.pnpApi.getLocator(this.name, dependencyReference));
        if (pkgInformation === null)
            throw new Error(`Assertion failed: Package ${this.name} isn't a dependency of the top-level`);
        const manifest = dynamicRequire_1.dynamicRequire(fslib_1.npath.join(pkgInformation.packageLocation, `package.json`));
        await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(absWrapperPath), { recursive: true });
        await fslib_1.xfs.writeJsonPromise(absWrapperPath, {
            name: this.name,
            version: `${manifest.version}-pnpify`,
            main: manifest.main,
            type: `commonjs`,
        });
    }
    async writeBinary(relPackagePath, options = {}) {
        const absPackagePath = await this.writeFile(relPackagePath, options);
        await fslib_1.xfs.chmodPromise(absPackagePath, 0o755);
    }
    async writeFile(relPackagePath, options = {}) {
        const topLevelInformation = this.pnpApi.getPackageInformation(this.pnpApi.topLevel);
        const projectRoot = fslib_1.npath.toPortablePath(topLevelInformation.packageLocation);
        const absWrapperPath = fslib_1.ppath.join(this.target, this.name, relPackagePath);
        const relProjectPath = fslib_1.ppath.relative(projectRoot, absWrapperPath);
        const absPnpApiPath = fslib_1.npath.toPortablePath(this.pnpApi.resolveRequest(`pnpapi`, null));
        const relPnpApiPath = fslib_1.ppath.relative(fslib_1.ppath.dirname(absWrapperPath), absPnpApiPath);
        await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(absWrapperPath), { recursive: true });
        await fslib_1.xfs.writeFilePromise(absWrapperPath, TEMPLATE(relPnpApiPath, fslib_1.ppath.join(this.name, relPackagePath), options));
        this.paths.set(relPackagePath, relProjectPath);
        return absWrapperPath;
    }
    getProjectPathTo(relPackagePath) {
        const relProjectPath = this.paths.get(relPackagePath);
        if (typeof relProjectPath === `undefined`)
            throw new Error(`Assertion failed: Expected path to have been registered`);
        return relProjectPath;
    }
}
exports.Wrapper = Wrapper;
const generateSdk = async (pnpApi, { requestedIntegrations, preexistingIntegrations }, { report, onlyBase, verbose, configuration }) => {
    const Mark = core_1.formatUtils.mark(configuration);
    const topLevelInformation = pnpApi.getPackageInformation(pnpApi.topLevel);
    const projectRoot = fslib_1.npath.toPortablePath(topLevelInformation.packageLocation);
    const targetFolder = fslib_1.ppath.join(projectRoot, exports.SDK_FOLDER);
    const allIntegrations = new Set([
        ...requestedIntegrations,
        ...preexistingIntegrations,
    ]);
    // TODO: remove in next major
    const oldTargetFolder = fslib_1.ppath.join(projectRoot, exports.OLD_SDK_FOLDER);
    if (fslib_1.xfs.existsSync(oldTargetFolder) && !fslib_1.xfs.lstatSync(oldTargetFolder).isSymbolicLink()) {
        report.reportWarning(core_1.MessageName.UNNAMED, `Cleaning up the existing SDK files in the old ${core_1.formatUtils.pretty(configuration, exports.OLD_SDK_FOLDER, core_1.formatUtils.Type.PATH)} folder. You might need to manually update existing references outside the ${core_1.formatUtils.pretty(configuration, `.vscode`, core_1.formatUtils.Type.PATH)} folder (e.g. .gitignore)...`);
        await fslib_1.xfs.removePromise(oldTargetFolder);
    }
    if (fslib_1.xfs.existsSync(targetFolder)) {
        report.reportWarning(core_1.MessageName.UNNAMED, `Cleaning up the existing SDK files...`);
        await fslib_1.xfs.removePromise(targetFolder);
    }
    const integrationsFile = new IntegrationsFile();
    integrationsFile.integrations = allIntegrations;
    await integrationsFile.persist(targetFolder);
    const integrationSdks = core_1.miscUtils.mapAndFilter(exports.SUPPORTED_INTEGRATIONS, ([integration, sdk]) => {
        if (!allIntegrations.has(integration))
            return core_1.miscUtils.mapAndFilter.skip;
        return sdk;
    });
    await report.startTimerPromise(`Generating SDKs inside ${core_1.formatUtils.pretty(configuration, exports.SDK_FOLDER, core_1.formatUtils.Type.PATH)}`, async () => {
        var _a;
        const skipped = [];
        for (const sdks of integrationSdks) {
            const defaultSdk = sdks.find(sdk => sdk[0] === null);
            if (!defaultSdk)
                continue;
            const [, generateDefaultWrapper] = defaultSdk;
            await ((_a = generateDefaultWrapper) === null || _a === void 0 ? void 0 : _a(pnpApi, targetFolder));
        }
        for (const [pkgName, generateBaseWrapper] of base_1.BASE_SDKS) {
            const displayName = exports.getDisplayName(pkgName);
            if (topLevelInformation.packageDependencies.has(pkgName)) {
                report.reportInfo(core_1.MessageName.UNNAMED, `${Mark.Check} ${displayName}`);
                const wrapper = await generateBaseWrapper(pnpApi, targetFolder);
                for (const sdks of integrationSdks) {
                    const sdk = sdks.find(sdk => sdk[0] === pkgName);
                    if (!sdk)
                        continue;
                    const [, generateIntegrationWrapper] = sdk;
                    if (!generateIntegrationWrapper)
                        continue;
                    await generateIntegrationWrapper(pnpApi, targetFolder, wrapper);
                }
            }
            else {
                skipped.push(displayName);
            }
        }
        if (skipped.length > 0) {
            if (verbose) {
                for (const displayName of skipped) {
                    report.reportWarning(core_1.MessageName.UNNAMED, `${chalk_1.default.yellow(`•`)} ${displayName} (dependency not found; skipped)`);
                }
            }
            else {
                report.reportWarning(core_1.MessageName.UNNAMED, `${chalk_1.default.yellow(`•`)} ${skipped.length} SDKs were skipped based on your root dependencies`);
            }
        }
    });
    if (allIntegrations.size > 0) {
        await report.startTimerPromise(`Generating settings`, async () => {
            for (const integration of allIntegrations) {
                if (preexistingIntegrations.has(integration)) {
                    report.reportInfo(core_1.MessageName.UNNAMED, `${Mark.Check} ${exports.getDisplayName(integration)} (updated 🔼)`);
                }
                else {
                    report.reportInfo(core_1.MessageName.UNNAMED, `${Mark.Check} ${exports.getDisplayName(integration)} (new ✨)`);
                }
            }
        });
    }
};
exports.generateSdk = generateSdk;
