"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const dynamicRequire_1 = require("../dynamicRequire");
const generateSdk_1 = require("../generateSdk");
// eslint-disable-next-line arca/no-default-export
class SdkCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.integrations = [];
        this.cwd = process.cwd();
        this.verbose = false;
    }
    async execute() {
        var _a;
        let nextProjectRoot = fslib_1.npath.toPortablePath(this.cwd);
        let currProjectRoot = null;
        let isCJS = ``;
        while (nextProjectRoot !== currProjectRoot) {
            currProjectRoot = nextProjectRoot;
            nextProjectRoot = fslib_1.ppath.dirname(currProjectRoot);
            if (fslib_1.xfs.existsSync(fslib_1.ppath.join(currProjectRoot, `.pnp.js`)))
                break;
            if (fslib_1.xfs.existsSync(fslib_1.ppath.join(currProjectRoot, `.pnp.cjs`))) {
                isCJS = `c`;
                break;
            }
        }
        if (nextProjectRoot === currProjectRoot)
            throw new Error(`This tool can only be used with projects using Yarn Plug'n'Play`);
        const configuration = core_1.Configuration.create(currProjectRoot);
        const pnpPath = fslib_1.ppath.join(currProjectRoot, `.pnp.${isCJS}js`);
        const pnpApi = dynamicRequire_1.dynamicRequire(fslib_1.npath.fromPortablePath(pnpPath));
        // Need to setup the fs patch so we can read from the archives
        (_a = pnpApi) === null || _a === void 0 ? void 0 : _a.setup();
        const onlyBase = this.integrations.length === 1 && this.integrations[0] === `base`;
        const requestedIntegrations = this.integrations.length === 0 || onlyBase
            ? new Set()
            : new Set(this.integrations);
        generateSdk_1.validateIntegrations(requestedIntegrations);
        const topLevelInformation = pnpApi.getPackageInformation(pnpApi.topLevel);
        const projectRoot = fslib_1.npath.toPortablePath(topLevelInformation.packageLocation);
        const integrationsFile = await generateSdk_1.IntegrationsFile.find(projectRoot);
        const preexistingIntegrations = integrationsFile !== null
            ? integrationsFile.integrations
            : new Set();
        const allIntegrations = new Set([
            ...requestedIntegrations,
            ...preexistingIntegrations,
        ]);
        if (allIntegrations.size === 0 && !onlyBase)
            throw new clipanion_1.UsageError(`No integrations have been provided as arguments, and no preexisting integrations could be found. Make sure to run \`yarn pnpify --sdk <integrations>\` first, or \`yarn pnpify --sdk base\` if you only need the SDK files and prefer to manage your own environment settings. Run \`yarn pnpify --sdk -h\` to see the list of supported integrations.`);
        const report = await core_1.StreamReport.start({
            configuration,
            includeFooter: false,
            stdout: this.context.stdout,
        }, async (report) => {
            await generateSdk_1.generateSdk(pnpApi, {
                requestedIntegrations,
                preexistingIntegrations,
            }, {
                report,
                onlyBase,
                configuration,
                verbose: this.verbose,
            });
        });
        return report.exitCode();
    }
}
SdkCommand.usage = clipanion_1.Command.Usage({
    description: `generate editor SDKs and settings`,
    details: `
      This command generates a new directory, \`.yarn/sdks\`, which includes the base SDKs.

      When used without arguments, it:

      - throws an error on non-pnpified projects

      - updates all existing SDKs and editor settings on already-pnpified projects

      The optional integrations arguments are a set of supported integrations, or the keyword \`base\`.

      - When \`base\` is used, only the base SDKs will be generated. This is useful for when an editor is not yet supported and you plan to manage the settings yourself.

      - When a set of integrations is used (e.g. \`vscode\`, \`vim\`, ...), the base SDKs will be installed plus all the settings relevant to the corresponding environments (for example on VSCode it would set \`typescript.tsdk\`).

      The supported integrations at this time are: ${[...generateSdk_1.SUPPORTED_INTEGRATIONS.keys()].map(integration => `\`${integration}\``).join(`, `)}.

      **Note:** This command always updates the already-installed SDKs and editor settings, no matter which arguments are passed.
    `,
    examples: [[
            `Generate the base SDKs`,
            `$0 --sdk base`,
        ], [
            `Generate the base SDKs and editor settings for supported editors`,
            `$0 --sdk vscode vim`,
        ], [
            `Update all generated SDKs and editor settings`,
            `$0 --sdk`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], SdkCommand.prototype, "integrations", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`--cwd`, { description: `The directory to run the command in` })
], SdkCommand.prototype, "cwd", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-v,--verbose`, { description: `Print all skipped dependencies` })
], SdkCommand.prototype, "verbose", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`--sdk`)
], SdkCommand.prototype, "execute", null);
exports.default = SdkCommand;
