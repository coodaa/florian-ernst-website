"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const dynamicRequire_1 = require("../dynamicRequire");
// eslint-disable-next-line arca/no-default-export
class RunCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.args = [];
        this.cwd = process.cwd();
    }
    async execute() {
        let { NODE_OPTIONS } = process.env;
        NODE_OPTIONS = `${NODE_OPTIONS || ``} --require ${dynamicRequire_1.dynamicRequire.resolve(`@yarnpkg/pnpify`)}`.trim();
        const { code } = await core_1.execUtils.pipevp(this.commandName, this.args, {
            cwd: fslib_1.npath.toPortablePath(this.cwd),
            stderr: this.context.stderr,
            stdin: this.context.stdin,
            stdout: this.context.stdout,
            env: { ...process.env, NODE_OPTIONS },
        });
        return code;
    }
}
RunCommand.usage = clipanion_1.Command.Usage({
    description: `run a command with a virtual node_modules folder`,
    details: `
      When a non-PnP-compliant project tries to access the \`node_modules\` directories (for example through \`readdir\` or \`readFile\`), PnPify intercepts those calls and converts them into calls to the PnP API. Then, based on the result, it simulates the existence of a virtual \`node_modules\` folder that the underlying tool will then consume - still unaware that the files are extracted from a virtual filesystem.

      The \`run\` keyword can be omitted if the executed command doesn't conflict with built-in commands.
    `,
    examples: [[
            `Run Angular using PnPify`,
            `$0 ng build`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.String()
], RunCommand.prototype, "commandName", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Proxy()
], RunCommand.prototype, "args", void 0);
tslib_1.__decorate([
    clipanion_1.Command.String(`--cwd`, { description: `The directory to run the command in` })
], RunCommand.prototype, "cwd", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(),
    clipanion_1.Command.Path(`run`)
], RunCommand.prototype, "execute", null);
exports.default = RunCommand;
