"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildLocatorMap = exports.buildNodeModulesTree = exports.getArchivePath = exports.NodeModulesHoistingLimits = exports.LinkType = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const fslib_2 = require("@yarnpkg/fslib");
const hoist_1 = require("./hoist");
// Babel doesn't support const enums, thats why we use non-const enum for LinkType in @yarnpkg/pnp
// But because of this TypeScript requires @yarnpkg/pnp during runtime
// To prevent this we redeclare LinkType enum here, to not depend on @yarnpkg/pnp during runtime
var LinkType;
(function (LinkType) {
    LinkType["HARD"] = "HARD";
    LinkType["SOFT"] = "SOFT";
})(LinkType = exports.LinkType || (exports.LinkType = {}));
var NodeModulesHoistingLimits;
(function (NodeModulesHoistingLimits) {
    NodeModulesHoistingLimits["WORKSPACES"] = "workspaces";
    NodeModulesHoistingLimits["DEPENDENCIES"] = "dependencies";
    NodeModulesHoistingLimits["NONE"] = "none";
})(NodeModulesHoistingLimits = exports.NodeModulesHoistingLimits || (exports.NodeModulesHoistingLimits = {}));
/** node_modules path segment */
const NODE_MODULES = `node_modules`;
/**
 * The workspace name suffix used internally by this implementation and appeneded to the name of workspace package.
 * It is needed to create and distinguuish special nodes for workspaces
 */
const WORKSPACE_NAME_SUFFIX = `$wsroot$`;
/**
 * Returns path to archive, if package location is inside the archive.
 *
 * @param packagePath package location
 *
 * @returns path to archive is location is insde the archive or null otherwise
 */
const getArchivePath = (packagePath) => packagePath.indexOf(`.zip/${NODE_MODULES}/`) >= 0 ?
    fslib_2.npath.toPortablePath(packagePath.split(`/${NODE_MODULES}/`)[0]) :
    null;
exports.getArchivePath = getArchivePath;
/**
 * Retrieve full package list and build hoisted `node_modules` directories
 * representation in-memory.
 *
 * @param pnp PnP API
 *
 * @returns hoisted `node_modules` directories representation in-memory
 */
const buildNodeModulesTree = (pnp, options) => {
    const { packageTree, hoistingLimits } = buildPackageTree(pnp, options);
    const hoistedTree = hoist_1.hoist(packageTree, { hoistingLimits });
    return populateNodeModulesTree(pnp, hoistedTree, options);
};
exports.buildNodeModulesTree = buildNodeModulesTree;
const stringifyLocator = (locator) => `${locator.name}@${locator.reference}`;
const buildLocatorMap = (nodeModulesTree) => {
    const map = new Map();
    for (const [location, val] of nodeModulesTree.entries()) {
        if (!val.dirList) {
            let entry = map.get(val.locator);
            if (!entry) {
                entry = { target: val.target, linkType: val.linkType, locations: [], aliases: val.aliases };
                map.set(val.locator, entry);
            }
            entry.locations.push(location);
        }
    }
    for (const val of map.values()) {
        // Sort locations by depth first and then alphabetically for determinism
        val.locations = val.locations.sort((loc1, loc2) => {
            const len1 = loc1.split(fslib_2.ppath.delimiter).length;
            const len2 = loc2.split(fslib_2.ppath.delimiter).length;
            return len1 !== len2 ? len2 - len1 : loc2.localeCompare(loc1);
        });
    }
    return map;
};
exports.buildLocatorMap = buildLocatorMap;
function isPortalLocator(locatorKey) {
    let descriptor = core_1.structUtils.parseDescriptor(locatorKey);
    if (core_1.structUtils.isVirtualDescriptor(descriptor))
        descriptor = core_1.structUtils.devirtualizeDescriptor(descriptor);
    return descriptor.range.startsWith(`portal:`);
}
/**
 * Traverses PnP tree and produces input for the `RawHoister`
 *
 * @param pnp PnP API
 *
 * @returns package tree, packages info and locators
 */
const buildPackageTree = (pnp, options) => {
    const pnpRoots = pnp.getDependencyTreeRoots();
    const hoistingLimits = new Map();
    const workspaceDependenciesMap = new Map();
    const topPkg = pnp.getPackageInformation(pnp.topLevel);
    if (topPkg === null)
        throw new Error(`Assertion failed: Expected the top-level package to have been registered`);
    const topLocator = pnp.findPackageLocator(topPkg.packageLocation);
    if (topLocator === null)
        throw new Error(`Assertion failed: Expected the top-level package to have a physical locator`);
    const topPkgPortableLocation = fslib_2.npath.toPortablePath(topPkg.packageLocation);
    const topLocatorKey = stringifyLocator(topLocator);
    if (options.project) {
        const workspaceTree = { children: new Map() };
        const cwdSegments = options.project.cwd.split(fslib_2.ppath.sep);
        for (const [cwd, workspace] of options.project.workspacesByCwd) {
            const segments = cwd.split(fslib_2.ppath.sep).slice(cwdSegments.length);
            let node = workspaceTree;
            for (const segment of segments) {
                let nextNode = node.children.get(segment);
                if (!nextNode) {
                    nextNode = { children: new Map() };
                    node.children.set(segment, nextNode);
                }
                node = nextNode;
            }
            node.workspaceLocator = { name: core_1.structUtils.stringifyIdent(workspace.anchoredLocator), reference: workspace.anchoredLocator.reference };
        }
        const addWorkspace = (node, parentWorkspaceLocator) => {
            if (node.workspaceLocator) {
                const parentLocatorKey = stringifyLocator(parentWorkspaceLocator);
                let dependencies = workspaceDependenciesMap.get(parentLocatorKey);
                if (!dependencies) {
                    dependencies = new Set();
                    workspaceDependenciesMap.set(parentLocatorKey, dependencies);
                }
                dependencies.add(node.workspaceLocator);
            }
            for (const child of node.children.values()) {
                addWorkspace(child, node.workspaceLocator || parentWorkspaceLocator);
            }
        };
        for (const child of workspaceTree.children.values()) {
            addWorkspace(child, workspaceTree.workspaceLocator);
        }
    }
    else {
        for (const locator of pnpRoots) {
            if (locator.name !== topLocator.name || locator.reference !== topLocator.reference) {
                let dependencies = workspaceDependenciesMap.get(topLocatorKey);
                if (!dependencies) {
                    dependencies = new Set();
                    workspaceDependenciesMap.set(topLocatorKey, dependencies);
                }
                dependencies.add(locator);
            }
        }
    }
    const packageTree = {
        name: topLocator.name,
        identName: topLocator.name,
        reference: topLocator.reference,
        peerNames: topPkg.packagePeers,
        dependencies: new Set(),
    };
    const nodes = new Map();
    const getNodeKey = (name, locator) => `${stringifyLocator(locator)}:${name}`;
    const addPackageToTree = (name, pkg, locator, parent, parentDependencies, parentRelativeCwd, isHoistBorder) => {
        var _a, _b;
        const nodeKey = getNodeKey(name, locator);
        let node = nodes.get(nodeKey);
        const isSeen = !!node;
        if (!isSeen && locator.name === topLocator.name && locator.reference === topLocator.reference) {
            node = packageTree;
            nodes.set(nodeKey, packageTree);
        }
        if (!node) {
            node = {
                name,
                identName: locator.name,
                reference: locator.reference,
                dependencies: new Set(),
                peerNames: pkg.packagePeers,
            };
            nodes.set(nodeKey, node);
        }
        if (isHoistBorder) {
            const parentLocatorKey = stringifyLocator({ name: parent.identName, reference: parent.reference });
            const dependencyBorders = hoistingLimits.get(parentLocatorKey) || new Set();
            hoistingLimits.set(parentLocatorKey, dependencyBorders);
            dependencyBorders.add(node.name);
        }
        const allDependencies = new Map(pkg.packageDependencies);
        if (options.project) {
            const workspace = options.project.workspacesByCwd.get(fslib_2.npath.toPortablePath(pkg.packageLocation.slice(0, -1)));
            if (workspace) {
                const peerCandidates = new Set([
                    ...Array.from(workspace.manifest.peerDependencies.values(), x => core_1.structUtils.stringifyIdent(x)),
                    ...Array.from(workspace.manifest.peerDependenciesMeta.keys()),
                ]);
                for (const peerName of peerCandidates) {
                    if (!allDependencies.has(peerName)) {
                        allDependencies.set(peerName, parentDependencies.get(peerName) || null);
                        node.peerNames.add(peerName);
                    }
                }
            }
        }
        const locatorKey = stringifyLocator(locator);
        const workspaceDependencies = workspaceDependenciesMap.get(locatorKey);
        if (workspaceDependencies) {
            for (const workspaceLocator of workspaceDependencies) {
                allDependencies.set(`${workspaceLocator.name}${WORKSPACE_NAME_SUFFIX}`, workspaceLocator.reference);
            }
        }
        parent.dependencies.add(node);
        // If we link dependencies to file system we must not try to install children dependencies inside portal folders
        const shouldAddChildrenDependencies = options.pnpifyFs || !isPortalLocator(nodeKey);
        if (!isSeen && shouldAddChildrenDependencies) {
            for (const [depName, referencish] of allDependencies) {
                if (referencish !== null) {
                    const depLocator = pnp.getLocator(depName, referencish);
                    const pkgLocator = pnp.getLocator(depName.replace(WORKSPACE_NAME_SUFFIX, ``), referencish);
                    const depPkg = pnp.getPackageInformation(pkgLocator);
                    if (depPkg === null)
                        throw new Error(`Assertion failed: Expected the package to have been registered`);
                    const parentHoistingLimits = (_a = options.hoistingLimitsByCwd) === null || _a === void 0 ? void 0 : _a.get(parentRelativeCwd);
                    const relativeDepCwd = fslib_2.ppath.relative(topPkgPortableLocation, fslib_2.npath.toPortablePath(depPkg.packageLocation)) || fslib_1.PortablePath.dot;
                    const depHoistingLimits = (_b = options.hoistingLimitsByCwd) === null || _b === void 0 ? void 0 : _b.get(relativeDepCwd);
                    const isHoistBorder = parentHoistingLimits === NodeModulesHoistingLimits.DEPENDENCIES
                        || depHoistingLimits === NodeModulesHoistingLimits.DEPENDENCIES
                        || depHoistingLimits === NodeModulesHoistingLimits.WORKSPACES;
                    addPackageToTree(depName, depPkg, depLocator, node, allDependencies, relativeDepCwd, isHoistBorder);
                }
            }
        }
    };
    addPackageToTree(topLocator.name, topPkg, topLocator, packageTree, topPkg.packageDependencies, fslib_1.PortablePath.dot, false);
    return { packageTree, hoistingLimits };
};
function getTargetLocatorPath(locator, pnp, options) {
    const pkgLocator = pnp.getLocator(locator.name.replace(WORKSPACE_NAME_SUFFIX, ``), locator.reference);
    const info = pnp.getPackageInformation(pkgLocator);
    if (info === null)
        throw new Error(`Assertion failed: Expected the package to be registered`);
    let linkType;
    let target;
    if (options.pnpifyFs) {
        // In case of pnpifyFs we represent modules as symlinks to archives in NodeModulesFS
        // `/home/user/project/foo` is a symlink to `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo`
        // To make this fs layout work with legacy tools we make
        // `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo/node_modules` (which normally does not exist inside archive) a symlink to:
        // `/home/user/project/node_modules/foo/node_modules`, so that the tools were able to access it
        target = fslib_2.npath.toPortablePath(info.packageLocation);
        linkType = LinkType.SOFT;
    }
    else {
        const truePath = pnp.resolveVirtual && locator.reference && locator.reference.startsWith(`virtual:`)
            ? pnp.resolveVirtual(info.packageLocation)
            : info.packageLocation;
        target = fslib_2.npath.toPortablePath(truePath || info.packageLocation);
        linkType = info.linkType;
    }
    return { linkType, target };
}
/**
 * Converts hoisted tree to node modules map
 *
 * @param pnp PnP API
 * @param hoistedTree hoisted package tree from `RawHoister`
 * @param locators locators
 * @param packages package weights
 *
 * @returns node modules map
 */
const populateNodeModulesTree = (pnp, hoistedTree, options) => {
    const tree = new Map();
    const makeLeafNode = (locator, aliases) => {
        const { linkType, target } = getTargetLocatorPath(locator, pnp, options);
        return {
            locator: stringifyLocator(locator),
            target,
            linkType,
            aliases,
        };
    };
    const getPackageName = (identName) => {
        const [nameOrScope, name] = identName.split(`/`);
        return name ? {
            scope: fslib_2.toFilename(nameOrScope),
            name: fslib_2.toFilename(name),
        } : {
            scope: null,
            name: fslib_2.toFilename(nameOrScope),
        };
    };
    const seenNodes = new Set();
    const buildTree = (pkg, locationPrefix) => {
        if (seenNodes.has(pkg))
            return;
        seenNodes.add(pkg);
        for (const dep of pkg.dependencies) {
            // We do not want self-references in node_modules, since they confuse existing tools
            if (dep === pkg || (pkg.identName.endsWith(WORKSPACE_NAME_SUFFIX) && dep.identName === pkg.identName.replace(WORKSPACE_NAME_SUFFIX, ``)))
                continue;
            const references = Array.from(dep.references).sort();
            const locator = { name: dep.identName, reference: references[0] };
            const { name, scope } = getPackageName(dep.name);
            const packageNameParts = scope
                ? [scope, name]
                : [name];
            const nodeModulesDirPath = fslib_2.ppath.join(locationPrefix, NODE_MODULES);
            const nodeModulesLocation = fslib_2.ppath.join(nodeModulesDirPath, ...packageNameParts);
            const leafNode = makeLeafNode(locator, references.slice(1));
            if (!dep.name.endsWith(WORKSPACE_NAME_SUFFIX)) {
                const prevNode = tree.get(nodeModulesLocation);
                if (prevNode) {
                    if (prevNode.dirList) {
                        throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge dir node with leaf node`);
                    }
                    else {
                        const locator1 = core_1.structUtils.parseLocator(prevNode.locator);
                        const locator2 = core_1.structUtils.parseLocator(leafNode.locator);
                        if (prevNode.linkType !== leafNode.linkType)
                            throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different link types`);
                        else if (locator1.identHash !== locator2.identHash)
                            throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different idents ${core_1.structUtils.stringifyLocator(locator1)} and ${core_1.structUtils.stringifyLocator(locator2)}`);
                        leafNode.aliases = [...leafNode.aliases, ...prevNode.aliases, core_1.structUtils.parseLocator(prevNode.locator).reference];
                    }
                }
                tree.set(nodeModulesLocation, leafNode);
                const segments = nodeModulesLocation.split(`/`);
                const nodeModulesIdx = segments.indexOf(NODE_MODULES);
                let segCount = segments.length - 1;
                while (nodeModulesIdx >= 0 && segCount > nodeModulesIdx) {
                    const dirPath = fslib_2.npath.toPortablePath(segments.slice(0, segCount).join(fslib_2.ppath.sep));
                    const targetDir = fslib_2.toFilename(segments[segCount]);
                    const subdirs = tree.get(dirPath);
                    if (!subdirs) {
                        tree.set(dirPath, { dirList: new Set([targetDir]) });
                    }
                    else if (subdirs.dirList) {
                        if (subdirs.dirList.has(targetDir)) {
                            break;
                        }
                        else {
                            subdirs.dirList.add(targetDir);
                        }
                    }
                    segCount--;
                }
            }
            buildTree(dep, leafNode.linkType === LinkType.SOFT ? leafNode.target : nodeModulesLocation);
        }
    };
    const rootNode = makeLeafNode({ name: hoistedTree.name, reference: Array.from(hoistedTree.references)[0] }, []);
    const rootPath = rootNode.target;
    tree.set(rootPath, rootNode);
    buildTree(hoistedTree, rootPath);
    return tree;
};
/**
 * Benchmarks raw hoisting performance.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const benchmarkRawHoisting = (packageTree) => {
    const iterCount = 10;
    const startTime = Date.now();
    for (let iter = 0; iter < iterCount; iter++)
        hoist_1.hoist(packageTree);
    const endTime = Date.now();
    return (endTime - startTime) / iterCount;
};
/**
 * Benchmarks node_modules tree building.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const benchmarkBuildTree = (pnp, options) => {
    const iterCount = 100;
    const startTime = Date.now();
    for (let iter = 0; iter < iterCount; iter++) {
        const { packageTree, hoistingLimits } = buildPackageTree(pnp, options);
        const hoistedTree = hoist_1.hoist(packageTree, { hoistingLimits });
        populateNodeModulesTree(pnp, hoistedTree, options);
    }
    const endTime = Date.now();
    return (endTime - startTime) / iterCount;
};
/**
 * Pretty-prints node_modules tree.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param tree node_modules tree
 * @param rootPath top-level project root folder
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const dumpNodeModulesTree = (tree, rootPath) => {
    const sortedTree = new Map();
    const keys = Array.from(tree.keys()).sort();
    for (const key of keys) {
        const val = tree.get(key);
        sortedTree.set(key, val.dirList ? { dirList: new Set(Array.from(val.dirList).sort()) } : val);
    }
    const seenPaths = new Set();
    const dumpTree = (nodePath, prefix = ``, dirPrefix = ``) => {
        const node = sortedTree.get(nodePath);
        if (!node)
            return ``;
        seenPaths.add(nodePath);
        let str = ``;
        if (node.dirList) {
            const dirs = Array.from(node.dirList);
            for (let idx = 0; idx < dirs.length; idx++) {
                const dir = dirs[idx];
                str += `${prefix}${idx < dirs.length - 1 ? `├─` : `└─`}${dirPrefix}${dir}\n`;
                str += dumpTree(fslib_2.ppath.join(nodePath, dir), `${prefix}${idx < dirs.length - 1 ? `│ ` : `  `}`);
            }
        }
        else {
            const { target, linkType } = node;
            str += dumpTree(fslib_2.ppath.join(nodePath, NODE_MODULES), `${prefix}│ `, `${NODE_MODULES}/`);
            str += `${prefix}└─${linkType === LinkType.SOFT ? `s>` : `>`}${target}\n`;
        }
        return str;
    };
    let str = dumpTree(fslib_2.ppath.join(rootPath, NODE_MODULES));
    for (const key of sortedTree.keys()) {
        if (!seenPaths.has(key)) {
            str += `${key.replace(rootPath, ``)}\n${dumpTree(key)}`;
        }
    }
    return str;
};
/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const dumpDepTree = (tree) => {
    const dumpLocator = (locator) => {
        if (locator.reference === `workspace:.`) {
            return `.`;
        }
        else if (!locator.reference) {
            return `${locator.name}@${locator.reference}`;
        }
        else {
            const version = (locator.reference.indexOf(`#`) > 0 ? locator.reference.split(`#`)[1] : locator.reference).replace(`npm:`, ``);
            if (locator.reference.startsWith(`virtual`)) {
                return `v:${locator.name}@${version}`;
            }
            else {
                return `${locator.name}@${version}`;
            }
        }
    };
    const dumpPackage = (pkg, parents, prefix = ``) => {
        if (parents.includes(pkg))
            return ``;
        const dependencies = Array.from(pkg.dependencies);
        let str = ``;
        for (let idx = 0; idx < dependencies.length; idx++) {
            const dep = dependencies[idx];
            str += `${prefix}${idx < dependencies.length - 1 ? `├─` : `└─`}${(parents.includes(dep) ? `>` : ``) + dumpLocator({ name: dep.name, reference: Array.from(dep.references)[0] })}\n`;
            str += dumpPackage(dep, [...parents, dep], `${prefix}${idx < dependencies.length - 1 ? `│ ` : `  `}`);
        }
        return str;
    };
    return dumpPackage(tree, []);
};
