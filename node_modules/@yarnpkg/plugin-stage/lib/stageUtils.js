"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genCommitMessage = exports.getCommitPrefix = exports.findConsensus = exports.checkConsensus = exports.expandDirectory = exports.isYarnFile = exports.findVcsRoot = exports.ActionType = void 0;
const fslib_1 = require("@yarnpkg/fslib");
var ActionType;
(function (ActionType) {
    ActionType[ActionType["CREATE"] = 0] = "CREATE";
    ActionType[ActionType["DELETE"] = 1] = "DELETE";
    ActionType[ActionType["ADD"] = 2] = "ADD";
    ActionType[ActionType["REMOVE"] = 3] = "REMOVE";
    ActionType[ActionType["MODIFY"] = 4] = "MODIFY";
})(ActionType = exports.ActionType || (exports.ActionType = {}));
async function findVcsRoot(cwd, { marker }) {
    do {
        if (!fslib_1.xfs.existsSync(fslib_1.ppath.join(cwd, marker))) {
            cwd = fslib_1.ppath.dirname(cwd);
        }
        else {
            return cwd;
        }
    } while (cwd !== `/`);
    return null;
}
exports.findVcsRoot = findVcsRoot;
function isYarnFile(path, { roots, names }) {
    if (names.has(fslib_1.ppath.basename(path)))
        return true;
    do {
        if (!roots.has(path)) {
            path = fslib_1.ppath.dirname(path);
        }
        else {
            return true;
        }
    } while (path !== `/`);
    return false;
}
exports.isYarnFile = isYarnFile;
function expandDirectory(initialCwd) {
    const paths = [];
    const cwds = [initialCwd];
    while (cwds.length > 0) {
        const cwd = cwds.pop();
        const listing = fslib_1.xfs.readdirSync(cwd);
        for (const entry of listing) {
            const path = fslib_1.ppath.resolve(cwd, entry);
            const stat = fslib_1.xfs.lstatSync(path);
            if (stat.isDirectory()) {
                cwds.push(path);
            }
            else {
                paths.push(path);
            }
        }
    }
    return paths;
}
exports.expandDirectory = expandDirectory;
function checkConsensus(lines, regex) {
    let yes = 0, no = 0;
    for (const line of lines) {
        if (line === `wip`)
            continue;
        if (regex.test(line)) {
            yes += 1;
        }
        else {
            no += 1;
        }
    }
    return yes >= no;
}
exports.checkConsensus = checkConsensus;
function findConsensus(lines) {
    const useThirdPerson = checkConsensus(lines, /^(\w\(\w+\):\s*)?\w+s/);
    const useUpperCase = checkConsensus(lines, /^(\w\(\w+\):\s*)?[A-Z]/);
    const useComponent = checkConsensus(lines, /^\w\(\w+\):/);
    return {
        useThirdPerson,
        useUpperCase,
        useComponent,
    };
}
exports.findConsensus = findConsensus;
function getCommitPrefix(consensus) {
    if (consensus.useComponent) {
        return `chore(yarn): `;
    }
    else {
        return ``;
    }
}
exports.getCommitPrefix = getCommitPrefix;
const VERBS = new Map([
    // Package actions
    [ActionType.CREATE, `create`],
    [ActionType.DELETE, `delete`],
    // File actions
    [ActionType.ADD, `add`],
    [ActionType.REMOVE, `remove`],
    [ActionType.MODIFY, `update`],
]);
function genCommitMessage(consensus, actions) {
    const prefix = getCommitPrefix(consensus);
    const all = [];
    const sorted = actions.slice().sort((a, b) => {
        return a[0] - b[0];
    });
    while (sorted.length > 0) {
        const [type, what] = sorted.shift();
        let verb = VERBS.get(type);
        if (consensus.useUpperCase && all.length === 0)
            verb = `${verb[0].toUpperCase()}${verb.slice(1)}`;
        if (consensus.useThirdPerson)
            verb += `s`;
        const subjects = [what];
        while (sorted.length > 0 && sorted[0][0] === type) {
            const [, what] = sorted.shift();
            subjects.push(what);
        }
        subjects.sort();
        let description = subjects.shift();
        if (subjects.length === 1)
            description += ` (and one other)`;
        else if (subjects.length > 1)
            description += ` (and ${subjects.length} others)`;
        all.push(`${verb} ${description}`);
    }
    return `${prefix}${all.join(`, `)}`;
}
exports.genCommitMessage = genCommitMessage;
