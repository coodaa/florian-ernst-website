"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const packUtils = __importStar(require("../packUtils"));
// eslint-disable-next-line arca/no-default-export
class PackCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.installIfNeeded = false;
        this.dryRun = false;
        this.json = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (await packUtils.hasPackScripts(workspace)) {
            if (this.installIfNeeded) {
                await project.install({
                    cache: await core_1.Cache.find(configuration),
                    report: new core_1.ThrowReport(),
                });
            }
            else {
                await project.restoreInstallState();
            }
        }
        const target = typeof this.out !== `undefined`
            ? fslib_1.ppath.resolve(this.context.cwd, interpolateOutputName(this.out, { workspace }))
            : fslib_1.ppath.resolve(workspace.cwd, `package.tgz`);
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            json: this.json,
        }, async (report) => {
            await packUtils.prepareForPack(workspace, { report }, async () => {
                report.reportJson({ base: workspace.cwd });
                const files = await packUtils.genPackList(workspace);
                for (const file of files) {
                    report.reportInfo(null, file);
                    report.reportJson({ location: file });
                }
                if (!this.dryRun) {
                    const pack = await packUtils.genPackStream(workspace, files);
                    const write = fslib_1.xfs.createWriteStream(target);
                    pack.pipe(write);
                    await new Promise(resolve => {
                        write.on(`finish`, resolve);
                    });
                }
            });
            if (!this.dryRun) {
                report.reportInfo(core_1.MessageName.UNNAMED, `Package archive generated in ${configuration.format(target, `magenta`)}`);
                report.reportJson({ output: target });
            }
        });
        return report.exitCode();
    }
}
PackCommand.usage = clipanion_1.Command.Usage({
    description: `generate a tarball from the active workspace`,
    details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`--install-if-needed\` flag is set Yarn will run a preliminary \`yarn install\` if the package contains build scripts.

      If the \`-n,--dry-run\` flag is set the command will just print the file paths without actually generating the package archive.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
    examples: [[
            `Create an archive from the active workspace`,
            `yarn pack`,
        ], [
            `List the files that would be made part of the workspace's archive`,
            `yarn pack --dry-run`,
        ], [
            `Name and output the archive in a dedicated folder`,
            `yarn pack --out /artifacts/%s-%v.tgz`,
        ]],
});
__decorate([
    clipanion_1.Command.Boolean(`--install-if-needed`)
], PackCommand.prototype, "installIfNeeded", void 0);
__decorate([
    clipanion_1.Command.Boolean(`-n,--dry-run`)
], PackCommand.prototype, "dryRun", void 0);
__decorate([
    clipanion_1.Command.Boolean(`--json`)
], PackCommand.prototype, "json", void 0);
__decorate([
    clipanion_1.Command.String(`--filename`, { hidden: false }),
    clipanion_1.Command.String(`-o,--out`)
], PackCommand.prototype, "out", void 0);
__decorate([
    clipanion_1.Command.Path(`pack`)
], PackCommand.prototype, "execute", null);
exports.default = PackCommand;
function interpolateOutputName(name, { workspace }) {
    const interpolated = name
        .replace(`%s`, prettyWorkspaceIdent(workspace))
        .replace(`%v`, prettyWorkspaceVersion(workspace));
    return fslib_1.npath.toPortablePath(interpolated);
}
function prettyWorkspaceIdent(workspace) {
    if (workspace.manifest.name !== null) {
        return core_1.structUtils.slugifyIdent(workspace.manifest.name);
    }
    else {
        return `package`;
    }
}
function prettyWorkspaceVersion(workspace) {
    if (workspace.manifest.version !== null) {
        return workspace.manifest.version;
    }
    else {
        return `unknown`;
    }
}
