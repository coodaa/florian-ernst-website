"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const micromatch_1 = __importDefault(require("micromatch"));
const stream_1 = require("stream");
const tar_stream_1 = __importDefault(require("tar-stream"));
const zlib_1 = require("zlib");
const NEVER_IGNORE = [
    `/package.json`,
    `/readme`,
    `/readme.*`,
    `/license`,
    `/license.*`,
    `/licence`,
    `/licence.*`,
    `/changelog`,
    `/changelog.*`,
];
const ALWAYS_IGNORE = [
    `/package.tgz`,
    `.github`,
    `.git`,
    `.hg`,
    `node_modules`,
    `.npmignore`,
    `.gitignore`,
    `.#*`,
    `.DS_Store`,
];
async function hasPackScripts(workspace) {
    if (await core_1.scriptUtils.hasWorkspaceScript(workspace, `prepack`))
        return true;
    if (await core_1.scriptUtils.hasWorkspaceScript(workspace, `postpack`))
        return true;
    return false;
}
exports.hasPackScripts = hasPackScripts;
async function prepareForPack(workspace, { report }, cb) {
    const stdin = null;
    const stdout = new stream_1.PassThrough();
    const stderr = new stream_1.PassThrough();
    if (await core_1.scriptUtils.hasWorkspaceScript(workspace, `prepack`)) {
        report.reportInfo(core_1.MessageName.LIFECYCLE_SCRIPT, `Calling the "prepack" lifecycle script`);
        const exitCode = await core_1.scriptUtils.executeWorkspaceScript(workspace, `prepack`, [], { stdin, stdout, stderr });
        if (exitCode !== 0) {
            throw new core_1.ReportError(core_1.MessageName.LIFECYCLE_SCRIPT, `Prepack script failed; run "yarn prepack" to investigate`);
        }
    }
    try {
        await cb();
    }
    finally {
        if (await core_1.scriptUtils.hasWorkspaceScript(workspace, `postpack`)) {
            report.reportInfo(core_1.MessageName.LIFECYCLE_SCRIPT, `Calling the "postpack" lifecycle script`);
            const exitCode = await core_1.scriptUtils.executeWorkspaceScript(workspace, `postpack`, [], { stdin, stdout, stderr });
            if (exitCode !== 0) {
                report.reportWarning(core_1.MessageName.LIFECYCLE_SCRIPT, `Postpack script failed; run "yarn postpack" to investigate`);
            }
        }
    }
}
exports.prepareForPack = prepareForPack;
async function genPackStream(workspace, files) {
    if (typeof files === `undefined`)
        files = await genPackList(workspace);
    const pack = tar_stream_1.default.pack();
    process.nextTick(async () => {
        for (const file of files) {
            const source = fslib_1.ppath.resolve(workspace.cwd, file);
            const dest = fslib_1.ppath.join(`package`, file);
            const stat = await fslib_1.xfs.lstatPromise(source);
            const opts = { name: dest, mtime: new Date(315532800) };
            let resolveFn;
            let rejectFn;
            let awaitTarget = new Promise((resolve, reject) => {
                resolveFn = resolve;
                rejectFn = reject;
            });
            const cb = (error) => {
                if (error) {
                    rejectFn(error);
                }
                else {
                    resolveFn();
                }
            };
            if (stat.isFile()) {
                let content;
                // The root package.json supports replacement fields in publishConfig
                if (file === `package.json`)
                    content = Buffer.from(JSON.stringify(await genPackageManifest(workspace), null, 2));
                else
                    content = await fslib_1.xfs.readFilePromise(source);
                pack.entry(Object.assign(Object.assign({}, opts), { type: `file` }), content, cb);
            }
            else if (stat.isSymbolicLink()) {
                pack.entry(Object.assign(Object.assign({}, opts), { type: `symlink`, linkname: await fslib_1.xfs.readlinkPromise(source) }), cb);
            }
            await awaitTarget;
        }
        pack.finalize();
    });
    const tgz = zlib_1.createGzip();
    pack.pipe(tgz);
    return tgz;
}
exports.genPackStream = genPackStream;
async function genPackageManifest(workspace) {
    const data = JSON.parse(JSON.stringify(workspace.manifest.raw));
    await workspace.project.configuration.triggerHook((hooks) => hooks.beforeWorkspacePacking, workspace, data);
    return data;
}
exports.genPackageManifest = genPackageManifest;
async function genPackList(workspace) {
    const project = workspace.project;
    const configuration = project.configuration;
    const globalList = {
        accept: [],
        reject: [],
    };
    for (const pattern of ALWAYS_IGNORE)
        globalList.reject.push(pattern);
    for (const pattern of NEVER_IGNORE)
        globalList.accept.push(pattern);
    globalList.reject.push(configuration.get(`rcFilename`));
    const maybeRejectPath = (path) => {
        if (path === null || !path.startsWith(`${workspace.cwd}/`))
            return;
        const workspaceRelativePath = fslib_1.ppath.relative(workspace.cwd, path);
        const workspaceAbsolutePath = fslib_1.ppath.resolve(fslib_1.PortablePath.root, workspaceRelativePath);
        globalList.reject.push(workspaceAbsolutePath);
    };
    maybeRejectPath(fslib_1.ppath.resolve(project.cwd, configuration.get(`lockfileFilename`)));
    maybeRejectPath(configuration.get(`bstatePath`));
    maybeRejectPath(configuration.get(`cacheFolder`));
    maybeRejectPath(configuration.get(`globalFolder`));
    maybeRejectPath(configuration.get(`virtualFolder`));
    maybeRejectPath(configuration.get(`yarnPath`));
    await configuration.triggerHook((hooks) => {
        return hooks.populateYarnPaths;
    }, project, (path) => {
        maybeRejectPath(path);
    });
    // All child workspaces are ignored
    for (const otherWorkspace of project.workspaces) {
        const rel = fslib_1.ppath.relative(workspace.cwd, otherWorkspace.cwd);
        if (rel !== `` && !rel.match(/^(\.\.)?\//)) {
            globalList.reject.push(`/${rel}`);
        }
    }
    const ignoreList = {
        accept: [],
        reject: [],
    };
    if (workspace.manifest.publishConfig && workspace.manifest.publishConfig.main)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, workspace.manifest.publishConfig.main));
    else if (workspace.manifest.main)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, workspace.manifest.main));
    if (workspace.manifest.publishConfig && workspace.manifest.publishConfig.module)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, workspace.manifest.publishConfig.module));
    else if (workspace.manifest.module)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, workspace.manifest.module));
    const hasExplicitFileList = workspace.manifest.files !== null;
    if (hasExplicitFileList) {
        ignoreList.reject.push(`/*`);
        for (const pattern of workspace.manifest.files) {
            addIgnorePattern(ignoreList.accept, pattern, { cwd: fslib_1.PortablePath.root });
        }
    }
    return await walk(workspace.cwd, {
        hasExplicitFileList,
        globalList,
        ignoreList,
    });
}
exports.genPackList = genPackList;
async function walk(initialCwd, { hasExplicitFileList, globalList, ignoreList }) {
    const list = [];
    const cwdFs = new fslib_1.JailFS(initialCwd);
    const cwdList = [[fslib_1.PortablePath.root, [ignoreList]]];
    while (cwdList.length > 0) {
        const [cwd, ignoreLists] = cwdList.pop();
        const stat = await cwdFs.lstatPromise(cwd);
        if (isIgnored(cwd, { globalList, ignoreLists: stat.isDirectory() ? null : ignoreLists }))
            continue;
        if (stat.isDirectory()) {
            const entries = await cwdFs.readdirPromise(cwd);
            let hasGitIgnore = false;
            let hasNpmIgnore = false;
            if (!hasExplicitFileList || cwd !== fslib_1.PortablePath.root) {
                for (const entry of entries) {
                    hasGitIgnore = hasGitIgnore || entry === `.gitignore`;
                    hasNpmIgnore = hasNpmIgnore || entry === `.npmignore`;
                }
            }
            const localIgnoreList = hasNpmIgnore
                ? await loadIgnoreList(cwdFs, cwd, fslib_1.toFilename(`.npmignore`))
                : hasGitIgnore
                    ? await loadIgnoreList(cwdFs, cwd, fslib_1.toFilename(`.gitignore`))
                    : null;
            let nextIgnoreLists = localIgnoreList !== null
                ? [localIgnoreList].concat(ignoreLists)
                : ignoreLists;
            if (isIgnored(cwd, { globalList, ignoreLists }))
                nextIgnoreLists = [...ignoreLists, { accept: [], reject: [`**/*`] }];
            for (const entry of entries) {
                cwdList.push([fslib_1.ppath.resolve(cwd, entry), nextIgnoreLists]);
            }
        }
        else {
            list.push(fslib_1.ppath.relative(fslib_1.PortablePath.root, cwd));
        }
    }
    return list.sort();
}
async function loadIgnoreList(fs, cwd, filename) {
    const ignoreList = {
        accept: [],
        reject: [],
    };
    const data = await fs.readFilePromise(fslib_1.ppath.join(cwd, filename), `utf8`);
    for (const pattern of data.split(/\n/g))
        addIgnorePattern(ignoreList.reject, pattern, { cwd });
    return ignoreList;
}
function normalizePattern(pattern, { cwd }) {
    const negated = pattern[0] === `!`;
    if (negated)
        pattern = pattern.slice(1);
    if (pattern.match(/\.{0,1}\//))
        pattern = fslib_1.ppath.resolve(cwd, pattern);
    if (negated)
        pattern = `!${pattern}`;
    return pattern;
}
;
function addIgnorePattern(target, pattern, { cwd }) {
    let trimed = pattern.trim();
    if (trimed === `` || trimed[0] === `#`)
        return;
    target.push(normalizePattern(trimed, { cwd }));
}
function isIgnored(cwd, { globalList, ignoreLists }) {
    if (isMatch(cwd, globalList.accept))
        return false;
    if (isMatch(cwd, globalList.reject))
        return true;
    if (ignoreLists !== null) {
        for (const ignoreList of ignoreLists) {
            if (isMatch(cwd, ignoreList.accept))
                return false;
            if (isMatch(cwd, ignoreList.reject)) {
                return true;
            }
        }
    }
    return false;
}
function isMatch(path, patterns) {
    let inclusives = patterns;
    let exclusives = [];
    for (let t = 0; t < patterns.length; ++t) {
        if (patterns[t][0] !== `!`) {
            if (inclusives !== patterns) {
                inclusives.push(patterns[t]);
            }
        }
        else {
            if (inclusives === patterns)
                inclusives = patterns.slice(0, t);
            exclusives.push(patterns[t].slice(1));
        }
    }
    if (isMatchBasename(path, exclusives))
        return false;
    if (isMatchBasename(path, inclusives))
        return true;
    return false;
}
function isMatchBasename(path, patterns) {
    let paths = patterns;
    let basenames = [];
    for (let t = 0; t < patterns.length; ++t) {
        if (patterns[t].includes(`/`)) {
            if (paths !== patterns) {
                paths.push(patterns[t]);
            }
        }
        else {
            if (paths === patterns)
                paths = patterns.slice(0, t);
            basenames.push(patterns[t]);
        }
    }
    if (micromatch_1.default.isMatch(path, paths, { dot: true, nocase: true }))
        return true;
    if (micromatch_1.default.isMatch(path, basenames, { dot: true, basename: true, nocase: true }))
        return true;
    return false;
}
