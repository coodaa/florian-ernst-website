"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasBindingGyp = exports.getExtractHint = exports.extractBuildScripts = exports.checkAndReportManifestCompatibility = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
function checkAndReportManifestCompatibility(pkg, requirements, label, { configuration, report }) {
    if (!core_1.Manifest.isManifestFieldCompatible(requirements.manifest.os, process.platform)) {
        report === null || report === void 0 ? void 0 : report.reportWarningOnce(core_1.MessageName.INCOMPATIBLE_OS, `${core_1.structUtils.prettyLocator(configuration, pkg)} The platform ${process.platform} is incompatible with this module, ${label} skipped.`);
        return false;
    }
    if (!core_1.Manifest.isManifestFieldCompatible(requirements.manifest.cpu, process.arch)) {
        report === null || report === void 0 ? void 0 : report.reportWarningOnce(core_1.MessageName.INCOMPATIBLE_CPU, `${core_1.structUtils.prettyLocator(configuration, pkg)} The CPU architecture ${process.arch} is incompatible with this module, ${label} skipped.`);
        return false;
    }
    return true;
}
exports.checkAndReportManifestCompatibility = checkAndReportManifestCompatibility;
function extractBuildScripts(pkg, requirements, dependencyMeta, { configuration, report }) {
    const buildScripts = [];
    for (const scriptName of [`preinstall`, `install`, `postinstall`])
        if (requirements.manifest.scripts.has(scriptName))
            buildScripts.push([core_1.BuildType.SCRIPT, scriptName]);
    // Detect cases where a package has a binding.gyp but no install script
    if (!requirements.manifest.scripts.has(`install`) && requirements.misc.hasBindingGyp)
        buildScripts.push([core_1.BuildType.SHELLCODE, `node-gyp rebuild`]);
    if (buildScripts.length === 0)
        return [];
    if (!configuration.get(`enableScripts`) && !dependencyMeta.built) {
        report === null || report === void 0 ? void 0 : report.reportWarningOnce(core_1.MessageName.DISABLED_BUILD_SCRIPTS, `${core_1.structUtils.prettyLocator(configuration, pkg)} lists build scripts, but all build scripts have been disabled.`);
        return [];
    }
    if (pkg.linkType !== core_1.LinkType.HARD) {
        report === null || report === void 0 ? void 0 : report.reportWarningOnce(core_1.MessageName.SOFT_LINK_BUILD, `${core_1.structUtils.prettyLocator(configuration, pkg)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
        return [];
    }
    if (dependencyMeta && dependencyMeta.built === false) {
        report === null || report === void 0 ? void 0 : report.reportInfoOnce(core_1.MessageName.BUILD_DISABLED, `${core_1.structUtils.prettyLocator(configuration, pkg)} lists build scripts, but its build has been explicitly disabled through configuration.`);
        return [];
    }
    const isManifestCompatible = checkAndReportManifestCompatibility(pkg, requirements, `build`, { configuration, report });
    if (!isManifestCompatible)
        return [];
    return buildScripts;
}
exports.extractBuildScripts = extractBuildScripts;
const FORCED_EXTRACT_FILETYPES = new Set([
    // Windows can't execute exe files inside zip archives
    `.exe`,
    // The c/c++ compiler can't read files from zip archives
    `.h`, `.hh`, `.hpp`, `.c`, `.cc`, `.cpp`,
    // The java runtime can't read files from zip archives
    `.java`, `.jar`,
    // Node opens these through dlopen
    `.node`,
]);
function getExtractHint(fetchResult) {
    return fetchResult.packageFs.getExtractHint({ relevantExtensions: FORCED_EXTRACT_FILETYPES });
}
exports.getExtractHint = getExtractHint;
function hasBindingGyp(fetchResult) {
    const bindingFilePath = fslib_1.ppath.join(fetchResult.prefixPath, `binding.gyp`);
    return fetchResult.packageFs.existsSync(bindingFilePath);
}
exports.hasBindingGyp = hasBindingGyp;
