"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpInstaller = exports.PnpLinker = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const pnp_1 = require("@yarnpkg/pnp");
const clipanion_1 = require("clipanion");
const index_1 = require("./index");
const jsInstallUtils = tslib_1.__importStar(require("./jsInstallUtils"));
const pnpUtils = tslib_1.__importStar(require("./pnpUtils"));
const FORCED_UNPLUG_PACKAGES = new Set([
    // Some packages do weird stuff and MUST be unplugged. I don't like them.
    core_1.structUtils.makeIdent(null, `nan`).identHash,
    core_1.structUtils.makeIdent(null, `node-gyp`).identHash,
    core_1.structUtils.makeIdent(null, `node-pre-gyp`).identHash,
    core_1.structUtils.makeIdent(null, `node-addon-api`).identHash,
    // Those ones contain native builds (*.node), and Node loads them through dlopen
    core_1.structUtils.makeIdent(null, `fsevents`).identHash,
]);
class PnpLinker {
    constructor() {
        this.mode = `strict`;
    }
    supportsPackage(pkg, opts) {
        if (opts.project.configuration.get(`nodeLinker`) !== `pnp`)
            return false;
        if (opts.project.configuration.get(`pnpMode`) !== this.mode)
            return false;
        return true;
    }
    async findPackageLocation(locator, opts) {
        const pnpPath = index_1.getPnpPath(opts.project).main;
        if (!fslib_1.xfs.existsSync(pnpPath))
            throw new clipanion_1.UsageError(`The project in ${core_1.formatUtils.pretty(opts.project.configuration, `${opts.project.cwd}/package.json`, core_1.formatUtils.Type.PATH)} doesn't seem to have been installed - running an install there might help`);
        const pnpFile = core_1.miscUtils.dynamicRequireNoCache(pnpPath);
        const packageLocator = { name: core_1.structUtils.requirableIdent(locator), reference: locator.reference };
        const packageInformation = pnpFile.getPackageInformation(packageLocator);
        if (!packageInformation)
            throw new clipanion_1.UsageError(`Couldn't find ${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} in the currently installed PnP map - running an install might help`);
        return fslib_1.npath.toPortablePath(packageInformation.packageLocation);
    }
    async findPackageLocator(location, opts) {
        const pnpPath = index_1.getPnpPath(opts.project).main;
        if (!fslib_1.xfs.existsSync(pnpPath))
            return null;
        const physicalPath = fslib_1.npath.fromPortablePath(pnpPath);
        const pnpFile = core_1.miscUtils.dynamicRequire(physicalPath);
        delete require.cache[physicalPath];
        const locator = pnpFile.findPackageLocator(fslib_1.npath.fromPortablePath(location));
        if (!locator)
            return null;
        return core_1.structUtils.makeLocator(core_1.structUtils.parseIdent(locator.name), locator.reference);
    }
    makeInstaller(opts) {
        return new PnpInstaller(opts);
    }
}
exports.PnpLinker = PnpLinker;
class PnpInstaller {
    constructor(opts) {
        this.opts = opts;
        this.mode = `strict`;
        this.packageRegistry = new Map();
        this.virtualTemplates = new Map();
        this.customData = {
            store: new Map(),
        };
        this.unpluggedPaths = new Set();
        this.opts = opts;
    }
    getCustomDataKey() {
        return JSON.stringify({
            name: `PnpInstaller`,
            version: 1,
        });
    }
    attachCustomData(customData) {
        this.customData = customData;
    }
    async installPackage(pkg, fetchResult) {
        const key1 = core_1.structUtils.requirableIdent(pkg);
        const key2 = pkg.reference;
        const isWorkspace = !!this.opts.project.tryWorkspaceByLocator(pkg);
        const hasVirtualInstances = 
        // Only packages with peer dependencies have virtual instances
        pkg.peerDependencies.size > 0 &&
            // Only packages with peer dependencies have virtual instances
            !core_1.structUtils.isVirtualLocator(pkg);
        const mayNeedToBeBuilt = 
        // Virtual instance templates don't need to be built, since they don't truly exist
        !hasVirtualInstances &&
            // Workspaces aren't built by the linkers; they are managed by the core itself
            !isWorkspace;
        const mayNeedToBeUnplugged = 
        // Virtual instance templates don't need to be unplugged, since they don't truly exist
        !hasVirtualInstances &&
            // We never need to unplug soft links, since we don't control them
            pkg.linkType !== core_2.LinkType.SOFT;
        let customPackageData = this.customData.store.get(pkg.locatorHash);
        if (typeof customPackageData === `undefined`) {
            customPackageData = await extractCustomPackageData(pkg, fetchResult);
            if (pkg.linkType === core_2.LinkType.HARD) {
                this.customData.store.set(pkg.locatorHash, customPackageData);
            }
        }
        const dependencyMeta = this.opts.project.getDependencyMeta(pkg, pkg.version);
        const buildScripts = mayNeedToBeBuilt
            ? jsInstallUtils.extractBuildScripts(pkg, customPackageData, dependencyMeta, { configuration: this.opts.project.configuration, report: this.opts.report })
            : [];
        const packageFs = mayNeedToBeUnplugged
            ? await this.unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta)
            : fetchResult.packageFs;
        if (fslib_1.ppath.isAbsolute(fetchResult.prefixPath))
            throw new Error(`Assertion failed: Expected the prefix path (${fetchResult.prefixPath}) to be relative to the parent`);
        const packageRawLocation = fslib_1.ppath.resolve(packageFs.getRealPath(), fetchResult.prefixPath);
        const packageLocation = normalizeDirectoryPath(this.opts.project.cwd, packageRawLocation);
        const packageDependencies = new Map();
        const packagePeers = new Set();
        // Only virtual packages should have effective peer dependencies, but the
        // workspaces are a special case because the original packages are kept in
        // the dependency tree even after being virtualized; so in their case we
        // just ignore their declared peer dependencies.
        if (core_1.structUtils.isVirtualLocator(pkg)) {
            for (const descriptor of pkg.peerDependencies.values()) {
                packageDependencies.set(core_1.structUtils.requirableIdent(descriptor), null);
                packagePeers.add(core_1.structUtils.stringifyIdent(descriptor));
            }
            if (!this.opts.project.tryWorkspaceByLocator(pkg)) {
                const devirtualized = core_1.structUtils.devirtualizeLocator(pkg);
                this.virtualTemplates.set(devirtualized.locatorHash, {
                    location: normalizeDirectoryPath(this.opts.project.cwd, fslib_1.VirtualFS.resolveVirtual(packageRawLocation)),
                    locator: devirtualized,
                });
            }
        }
        core_1.miscUtils.getMapWithDefault(this.packageRegistry, key1).set(key2, {
            packageLocation,
            packageDependencies,
            packagePeers,
            linkType: pkg.linkType,
            discardFromLookup: fetchResult.discardFromLookup || false,
        });
        return {
            packageLocation: packageRawLocation,
            buildDirective: buildScripts.length > 0 ? buildScripts : null,
        };
    }
    async attachInternalDependencies(locator, dependencies) {
        const packageInformation = this.getPackageInformation(locator);
        for (const [descriptor, locator] of dependencies) {
            const target = !core_1.structUtils.areIdentsEqual(descriptor, locator)
                ? [core_1.structUtils.requirableIdent(locator), locator.reference]
                : locator.reference;
            packageInformation.packageDependencies.set(core_1.structUtils.requirableIdent(descriptor), target);
        }
    }
    async attachExternalDependents(locator, dependentPaths) {
        for (const dependentPath of dependentPaths) {
            const packageInformation = this.getDiskInformation(dependentPath);
            packageInformation.packageDependencies.set(core_1.structUtils.requirableIdent(locator), locator.reference);
        }
    }
    async finalizeInstall() {
        const blacklistedPaths = new Set();
        for (const { locator, location } of this.virtualTemplates.values()) {
            core_1.miscUtils.getMapWithDefault(this.packageRegistry, core_1.structUtils.stringifyIdent(locator)).set(locator.reference, {
                packageLocation: location,
                packageDependencies: new Map(),
                packagePeers: new Set(),
                linkType: core_2.LinkType.SOFT,
                discardFromLookup: false,
            });
        }
        this.packageRegistry.set(null, new Map([
            [null, this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)],
        ]));
        const pnpFallbackMode = this.opts.project.configuration.get(`pnpFallbackMode`);
        const blacklistedLocations = blacklistedPaths;
        const dependencyTreeRoots = this.opts.project.workspaces.map(({ anchoredLocator }) => ({ name: core_1.structUtils.requirableIdent(anchoredLocator), reference: anchoredLocator.reference }));
        const enableTopLevelFallback = pnpFallbackMode !== `none`;
        const fallbackExclusionList = [];
        const fallbackPool = new Map();
        const ignorePattern = core_1.miscUtils.buildIgnorePattern([`.yarn/sdks/**`, ...this.opts.project.configuration.get(`pnpIgnorePatterns`)]);
        const packageRegistry = this.packageRegistry;
        const shebang = this.opts.project.configuration.get(`pnpShebang`);
        if (pnpFallbackMode === `dependencies-only`)
            for (const pkg of this.opts.project.storedPackages.values())
                if (this.opts.project.tryWorkspaceByLocator(pkg))
                    fallbackExclusionList.push({ name: core_1.structUtils.requirableIdent(pkg), reference: pkg.reference });
        await this.finalizeInstallWithPnp({
            blacklistedLocations,
            dependencyTreeRoots,
            enableTopLevelFallback,
            fallbackExclusionList,
            fallbackPool,
            ignorePattern,
            packageRegistry,
            shebang,
        });
        return {
            customData: this.customData,
        };
    }
    async finalizeInstallWithPnp(pnpSettings) {
        if (this.opts.project.configuration.get(`pnpMode`) !== this.mode)
            return;
        const pnpPath = index_1.getPnpPath(this.opts.project);
        const pnpDataPath = this.opts.project.configuration.get(`pnpDataPath`);
        await fslib_1.xfs.removePromise(pnpPath.other);
        if (this.opts.project.configuration.get(`nodeLinker`) !== `pnp`) {
            await fslib_1.xfs.removePromise(pnpPath.main);
            await fslib_1.xfs.removePromise(pnpDataPath);
            return;
        }
        const nodeModules = await this.locateNodeModules(pnpSettings.ignorePattern);
        if (nodeModules.length > 0) {
            this.opts.report.reportWarning(core_2.MessageName.DANGEROUS_NODE_MODULES, `One or more node_modules have been detected and will be removed. This operation may take some time.`);
            for (const nodeModulesPath of nodeModules) {
                await fslib_1.xfs.removePromise(nodeModulesPath);
            }
        }
        if (this.opts.project.configuration.get(`pnpEnableInlining`)) {
            const loaderFile = pnp_1.generateInlinedScript(pnpSettings);
            await fslib_1.xfs.changeFilePromise(pnpPath.main, loaderFile, { automaticNewlines: true });
            await fslib_1.xfs.chmodPromise(pnpPath.main, 0o755);
            await fslib_1.xfs.removePromise(pnpDataPath);
        }
        else {
            const dataLocation = fslib_1.ppath.relative(fslib_1.ppath.dirname(pnpPath.main), pnpDataPath);
            const { dataFile, loaderFile } = pnp_1.generateSplitScript({ ...pnpSettings, dataLocation });
            await fslib_1.xfs.changeFilePromise(pnpPath.main, loaderFile, { automaticNewlines: true });
            await fslib_1.xfs.chmodPromise(pnpPath.main, 0o755);
            await fslib_1.xfs.changeFilePromise(pnpDataPath, dataFile, { automaticNewlines: true });
            await fslib_1.xfs.chmodPromise(pnpDataPath, 0o644);
        }
        const pnpUnpluggedFolder = this.opts.project.configuration.get(`pnpUnpluggedFolder`);
        if (this.unpluggedPaths.size === 0) {
            await fslib_1.xfs.removePromise(pnpUnpluggedFolder);
        }
        else {
            for (const entry of await fslib_1.xfs.readdirPromise(pnpUnpluggedFolder)) {
                const unpluggedPath = fslib_1.ppath.resolve(pnpUnpluggedFolder, entry);
                if (!this.unpluggedPaths.has(unpluggedPath)) {
                    await fslib_1.xfs.removePromise(unpluggedPath);
                }
            }
        }
    }
    async locateNodeModules(ignorePattern) {
        const nodeModules = [];
        const ignoreRegExp = ignorePattern ? new RegExp(ignorePattern) : null;
        for (const workspace of this.opts.project.workspaces) {
            const nodeModulesPath = fslib_1.ppath.join(workspace.cwd, `node_modules`);
            if (ignoreRegExp && ignoreRegExp.test(fslib_1.ppath.relative(this.opts.project.cwd, workspace.cwd)) || !fslib_1.xfs.existsSync(nodeModulesPath))
                continue;
            const directoryListing = await fslib_1.xfs.readdirPromise(nodeModulesPath, {
                withFileTypes: true,
            });
            const nonCacheEntries = directoryListing.filter(entry => {
                return !entry.isDirectory() || entry.name === `.bin` || !entry.name.startsWith(`.`);
            });
            if (nonCacheEntries.length === directoryListing.length) {
                nodeModules.push(nodeModulesPath);
            }
            else {
                for (const entry of nonCacheEntries) {
                    nodeModules.push(fslib_1.ppath.join(nodeModulesPath, entry.name));
                }
            }
        }
        return nodeModules;
    }
    async unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta) {
        if (this.shouldBeUnplugged(pkg, customPackageData, dependencyMeta)) {
            return this.unplugPackage(pkg, fetchResult);
        }
        else {
            return fetchResult.packageFs;
        }
    }
    shouldBeUnplugged(pkg, customPackageData, dependencyMeta) {
        if (typeof dependencyMeta.unplugged !== `undefined`)
            return dependencyMeta.unplugged;
        if (FORCED_UNPLUG_PACKAGES.has(pkg.identHash))
            return true;
        if (customPackageData.manifest.preferUnplugged !== null)
            return customPackageData.manifest.preferUnplugged;
        if (jsInstallUtils.extractBuildScripts(pkg, customPackageData, dependencyMeta, { configuration: this.opts.project.configuration }).length > 0 || customPackageData.misc.extractHint)
            return true;
        return false;
    }
    async unplugPackage(locator, fetchResult) {
        const unplugPath = pnpUtils.getUnpluggedPath(locator, { configuration: this.opts.project.configuration });
        this.unpluggedPaths.add(unplugPath);
        const readyFile = fslib_1.ppath.join(unplugPath, fetchResult.prefixPath, `.ready`);
        if (await fslib_1.xfs.existsPromise(readyFile))
            return new fslib_1.CwdFS(unplugPath);
        await fslib_1.xfs.mkdirPromise(unplugPath, { recursive: true });
        await fslib_1.xfs.copyPromise(unplugPath, fslib_1.PortablePath.dot, { baseFs: fetchResult.packageFs, overwrite: false });
        await fslib_1.xfs.writeFilePromise(readyFile, ``);
        return new fslib_1.CwdFS(unplugPath);
    }
    getPackageInformation(locator) {
        const key1 = core_1.structUtils.requirableIdent(locator);
        const key2 = locator.reference;
        const packageInformationStore = this.packageRegistry.get(key1);
        if (!packageInformationStore)
            throw new Error(`Assertion failed: The package information store should have been available (for ${core_1.structUtils.prettyIdent(this.opts.project.configuration, locator)})`);
        const packageInformation = packageInformationStore.get(key2);
        if (!packageInformation)
            throw new Error(`Assertion failed: The package information should have been available (for ${core_1.structUtils.prettyLocator(this.opts.project.configuration, locator)})`);
        return packageInformation;
    }
    getDiskInformation(path) {
        const packageStore = core_1.miscUtils.getMapWithDefault(this.packageRegistry, `@@disk`);
        const normalizedPath = normalizeDirectoryPath(this.opts.project.cwd, path);
        return core_1.miscUtils.getFactoryWithDefault(packageStore, normalizedPath, () => ({
            packageLocation: normalizedPath,
            packageDependencies: new Map(),
            packagePeers: new Set(),
            linkType: core_2.LinkType.SOFT,
            discardFromLookup: false,
        }));
    }
}
exports.PnpInstaller = PnpInstaller;
function normalizeDirectoryPath(root, folder) {
    let relativeFolder = fslib_1.ppath.relative(root, folder);
    if (!relativeFolder.match(/^\.{0,2}\//))
        // Don't use ppath.join here, it ignores the `.`
        relativeFolder = `./${relativeFolder}`;
    return relativeFolder.replace(/\/?$/, `/`);
}
async function extractCustomPackageData(pkg, fetchResult) {
    var _a;
    const manifest = (_a = await core_2.Manifest.tryFind(fetchResult.prefixPath, { baseFs: fetchResult.packageFs })) !== null && _a !== void 0 ? _a : new core_2.Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
        if (!preservedScripts.has(scriptName))
            manifest.scripts.delete(scriptName);
    return {
        manifest: {
            os: manifest.os,
            cpu: manifest.cpu,
            scripts: manifest.scripts,
            preferUnplugged: manifest.preferUnplugged,
        },
        misc: {
            extractHint: jsInstallUtils.getExtractHint(fetchResult),
            hasBindingGyp: jsInstallUtils.hasBindingGyp(fetchResult),
        },
    };
}
