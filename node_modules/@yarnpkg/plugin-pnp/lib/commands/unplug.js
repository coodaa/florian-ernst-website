"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const pnpUtils = tslib_1.__importStar(require("../pnpUtils"));
// eslint-disable-next-line arca/no-default-export
class UnplugCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.patterns = [];
        this.all = false;
        this.recursive = false;
        this.json = false;
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (configuration.get(`nodeLinker`) !== `pnp`)
            throw new clipanion_1.UsageError(`This command can only be used if the \`nodeLinker\` option is set to \`pnp\``);
        await project.restoreInstallState();
        const unreferencedPatterns = new Set(this.patterns);
        const matchers = this.patterns.map(pattern => {
            const patternDescriptor = core_2.structUtils.parseDescriptor(pattern);
            const pseudoDescriptor = patternDescriptor.range !== `unknown`
                ? patternDescriptor
                : core_2.structUtils.makeDescriptor(patternDescriptor, `*`);
            if (!semver_1.default.validRange(pseudoDescriptor.range))
                throw new clipanion_1.UsageError(`The range of the descriptor patterns must be a valid semver range (${core_2.structUtils.prettyDescriptor(configuration, pseudoDescriptor)})`);
            return (pkg) => {
                const stringifiedIdent = core_2.structUtils.stringifyIdent(pkg);
                if (!micromatch_1.default.isMatch(stringifiedIdent, core_2.structUtils.stringifyIdent(pseudoDescriptor)))
                    return false;
                if (pkg.version && !core_2.semverUtils.satisfiesWithPrereleases(pkg.version, pseudoDescriptor.range))
                    return false;
                unreferencedPatterns.delete(pattern);
                return true;
            };
        });
        const getAllMatchingPackages = () => {
            const selection = [];
            for (const pkg of project.storedPackages.values())
                // Note: We can safely skip virtual packages here, as the
                // devirtualized copy will always exist inside storedPackages.
                if (!project.tryWorkspaceByLocator(pkg) && !core_2.structUtils.isVirtualLocator(pkg) && matchers.some(matcher => matcher(pkg)))
                    selection.push(pkg);
            return selection;
        };
        const getSelectedPackages = (roots) => {
            const seen = new Set();
            const selection = [];
            const traverse = (pkg, depth) => {
                if (seen.has(pkg.locatorHash))
                    return;
                seen.add(pkg.locatorHash);
                // Note: We shouldn't skip virtual packages, as
                // we don't iterate over the devirtualized copies.
                if (!project.tryWorkspaceByLocator(pkg) && matchers.some(matcher => matcher(pkg)))
                    selection.push(pkg);
                // Don't recurse unless requested
                if (depth > 0 && !this.recursive)
                    return;
                for (const dependency of pkg.dependencies.values()) {
                    const resolution = project.storedResolutions.get(dependency.descriptorHash);
                    if (!resolution)
                        throw new Error(`Assertion failed: The resolution should have been registered`);
                    const nextPkg = project.storedPackages.get(resolution);
                    if (!nextPkg)
                        throw new Error(`Assertion failed: The package should have been registered`);
                    traverse(nextPkg, depth + 1);
                }
            };
            for (const workspace of roots) {
                const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
                if (!pkg)
                    throw new Error(`Assertion failed: The package should have been registered`);
                traverse(pkg, 0);
            }
            return selection;
        };
        let selection;
        let projectOrWorkspaces;
        // We can shortcut the execution if we want all the dependencies and
        // transitive dependencies of all the branches: it means we want everything!
        if (this.all && this.recursive) {
            selection = getAllMatchingPackages();
            projectOrWorkspaces = `the project`;
        }
        else if (this.all) {
            selection = getSelectedPackages(project.workspaces);
            projectOrWorkspaces = `any workspace`;
        }
        else {
            selection = getSelectedPackages([workspace]);
            projectOrWorkspaces = `this workspace`;
        }
        if (unreferencedPatterns.size > 1)
            throw new clipanion_1.UsageError(`Patterns ${core_1.formatUtils.prettyList(configuration, unreferencedPatterns, core_1.formatUtils.Type.CODE)} don't match any packages referenced by ${projectOrWorkspaces}`);
        if (unreferencedPatterns.size > 0)
            throw new clipanion_1.UsageError(`Pattern ${core_1.formatUtils.prettyList(configuration, unreferencedPatterns, core_1.formatUtils.Type.CODE)} doesn't match any packages referenced by ${projectOrWorkspaces}`);
        selection = core_1.miscUtils.sortMap(selection, pkg => {
            return core_2.structUtils.stringifyLocator(pkg);
        });
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            json: this.json,
        }, async (report) => {
            var _a;
            for (const pkg of selection) {
                const version = (_a = pkg.version) !== null && _a !== void 0 ? _a : `unknown`;
                const dependencyMeta = project.topLevelWorkspace.manifest.ensureDependencyMeta(core_2.structUtils.makeDescriptor(pkg, version));
                dependencyMeta.unplugged = true;
                report.reportInfo(core_1.MessageName.UNNAMED, `Will unpack ${core_2.structUtils.prettyLocator(configuration, pkg)} to ${core_1.formatUtils.pretty(configuration, pnpUtils.getUnpluggedPath(pkg, { configuration }), core_1.formatUtils.Type.PATH)}`);
                report.reportJson({
                    locator: core_2.structUtils.stringifyLocator(pkg),
                    version,
                });
            }
            await project.topLevelWorkspace.persistManifest();
            report.reportSeparator();
            await project.install({ cache, report });
        });
        return report.exitCode();
    }
}
UnplugCommand.usage = clipanion_1.Command.Usage({
    description: `force the unpacking of a list of packages`,
    details: `
      This command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.

      A package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via \`pnpUnpluggedFolder\`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).

      Running the command will set a persistent flag inside your top-level \`package.json\`, in the \`dependenciesMeta\` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run \`yarn install\` to apply the modification.

      By default, only direct dependencies from the current workspace are affected. If \`-A,--all\` is set, direct dependencies from the entire project are affected. Using the \`-R,--recursive\` flag will affect transitive dependencies as well as direct ones.

      This command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.
    `,
    examples: [[
            `Unplug the lodash dependency from the active workspace`,
            `yarn unplug lodash`,
        ], [
            `Unplug all instances of lodash referenced by any workspace`,
            `yarn unplug lodash -A`,
        ], [
            `Unplug all instances of lodash referenced by the active workspace and its dependencies`,
            `yarn unplug lodash -R`,
        ], [
            `Unplug all instances of lodash, anywhere`,
            `yarn unplug lodash -AR`,
        ], [
            `Unplug one specific version of lodash`,
            `yarn unplug lodash@1.2.3`,
        ], [
            `Unplug all packages with the \`@babel\` scope`,
            `yarn unplug '@babel/*'`,
        ], [
            `Unplug all packages (only for testing, not recommended)`,
            `yarn unplug -R '*'`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], UnplugCommand.prototype, "patterns", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-A,--all`, { description: `Unplug direct dependencies from the entire project` })
], UnplugCommand.prototype, "all", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-R,--recursive`, { description: `Unplug both direct and transitive dependencies` })
], UnplugCommand.prototype, "recursive", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`--json`, { description: `Format the output as an NDJSON stream` })
], UnplugCommand.prototype, "json", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`unplug`)
], UnplugCommand.prototype, "execute", null);
exports.default = UnplugCommand;
